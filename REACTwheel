import React, { useState, useRef } from "react";

interface BubbleData {
  id: string;
  text: string;
  angle: number;
  distance: number;
  color: string;
  outlined?: boolean;
}

const ColorWheelInfographic: React.FC = () => {
  const svgRef = useRef<SVGSVGElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [innerSections, setInnerSections] = useState([
    { id: "1", text: "Category 1", color: "#FFB3BA" },
    { id: "2", text: "Category 2", color: "#FFDFBA" },
    { id: "3", text: "Category 3", color: "#BAFFC9" },
    { id: "4", text: "Category 4", color: "#BAE1FF" },
    { id: "5", text: "Category 5", color: "#E0BBE4" },
  ]);

  const [middleSections, setMiddleSections] = useState([
    { id: "1", text: "Middle 1", angle: 0, span: 72 },
    { id: "2", text: "Middle 2", angle: 72, span: 144 },
    { id: "3", text: "Middle 3", angle: 216, span: 144 },
  ]);

  const [bubbles, setBubbles] = useState<BubbleData[]>([
    {
      id: "1",
      text: "Bubble 1",
      angle: 45,
      distance: 180,
      color: "#FFB6C1",
    },
    {
      id: "2",
      text: "Bubble 2",
      angle: 135,
      distance: 200,
      color: "#B6E5FF",
    },
    {
      id: "3",
      text: "Bubble 3",
      angle: 225,
      distance: 190,
      color: "#C1FFC1",
    },
    {
      id: "4",
      text: "Bubble 4",
      angle: 315,
      distance: 195,
      color: "#FFDAB6",
    },
  ]);

  const [outerLabels, setOuterLabels] = useState([
    { id: "1", text: "Red Category", angle: 30 },
    { id: "2", text: "Orange Category", angle: 90 },
    { id: "3", text: "Yellow Category", angle: 150 },
    { id: "4", text: "Green Category", angle: 210 },
    { id: "5", text: "Blue Category", angle: 270 },
    { id: "6", text: "Purple Category", angle: 330 },
  ]);

  const [nextBubbleId, setNextBubbleId] = useState(5);
  const [selectedBubbleId, setSelectedBubbleId] = useState<string | null>(null);
  const [selectedLabelId, setSelectedLabelId] = useState<string | null>(null);
  const [selectedInnerSectionId, setSelectedInnerSectionId] = useState<string | null>(null);
  const [selectedMiddleSectionId, setSelectedMiddleSectionId] = useState<string | null>(null);
  const [draggingBubbleId, setDraggingBubbleId] = useState<string | null>(null);
  const [editText, setEditText] = useState("");

  const centerX = 400;
  const centerY = 400;
  const innerRadius = 80;
  const middleInnerRadius = 80;
  const middleOuterRadius = 115;
  const bubbleZoneRadius = 300;
  const outerRingInnerRadius = 320;
  const outerRingOuterRadius = 380;

  const getColorWheelColor = (angle: number): string => {
    // Shifted 40 degrees clockwise total (20 + 20)
    let hue = (angle - 40 + 360) % 360;
    
    // Use smooth continuous functions instead of hard boundaries
    // Base values
    let saturation = 80;
    let lightness = 52;
    
    // Smooth sine-based variations for natural transitions
    const cycle = (hue / 360) * Math.PI * 2;
    saturation = 78 + Math.sin(cycle * 3) * 8; // Oscillates between 70-86
    lightness = 52 + Math.sin(cycle * 2 + Math.PI / 4) * 6; // Oscillates between 46-58
    
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  };

  const getPastelColorWheelColor = (angle: number): string => {
    let hue = (angle - 40 + 360) % 360;
    let saturation = 50;
    let lightness = 75;
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  };

  const getVibrantColorWheelColor = (angle: number): string => {
    let hue = (angle - 40 + 360) % 360;
    // More muted/greyer colors for center wheel
    let saturation = 35;
    let lightness = 65;

    if (hue >= 0 && hue < 30) {
      saturation = 40;
      lightness = 63;
    } else if (hue >= 30 && hue < 60) {
      saturation = 42;
      lightness = 65;
    } else if (hue >= 60 && hue < 90) {
      saturation = 38;
      lightness = 67;
    } else if (hue >= 90 && hue < 150) {
      saturation = 32;
      lightness = 65;
    } else if (hue >= 150 && hue < 210) {
      saturation = 30;
      lightness = 62;
    } else if (hue >= 210 && hue < 270) {
      saturation = 33;
      lightness = 65;
    } else if (hue >= 270 && hue < 330) {
      saturation = 36;
      lightness = 66;
    } else {
      saturation = 38;
      lightness = 64;
    }

    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  };

  const createSectionPath = (
    centerX: number,
    centerY: number,
    innerRadius: number,
    outerRadius: number,
    startAngle: number,
    endAngle: number,
  ): string => {
    const startAngleRad = (startAngle - 90) * (Math.PI / 180);
    const endAngleRad = (endAngle - 90) * (Math.PI / 180);

    const x1 = centerX + innerRadius * Math.cos(startAngleRad);
    const y1 = centerY + innerRadius * Math.sin(startAngleRad);
    const x2 = centerX + outerRadius * Math.cos(startAngleRad);
    const y2 = centerY + outerRadius * Math.sin(startAngleRad);
    const x3 = centerX + outerRadius * Math.cos(endAngleRad);
    const y3 = centerY + outerRadius * Math.sin(endAngleRad);
    const x4 = centerX + innerRadius * Math.cos(endAngleRad);
    const y4 = centerY + innerRadius * Math.sin(endAngleRad);

    const largeArc = endAngle - startAngle > 180 ? 1 : 0;

    return `
      M ${x1} ${y1}
      L ${x2} ${y2}
      A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${x3} ${y3}
      L ${x4} ${y4}
      A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x1} ${y1}
      Z
    `;
  };

  const polarToCartesian = (angle: number, radius: number) => {
    const angleRad = (angle - 90) * (Math.PI / 180);
    return {
      x: centerX + radius * Math.cos(angleRad),
      y: centerY + radius * Math.sin(angleRad),
    };
  };

  const cartesianToPolar = (x: number, y: number) => {
    const dx = x - centerX;
    const dy = y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
    if (angle < 0) angle += 360;
    return { angle, distance };
  };

  // Wrap text to max 20 characters per line, respecting carriage returns
  const wrapText = (text: string, maxChars: number = 20): string[] => {
    // First split by carriage returns/newlines
    const paragraphs = text.split(/\r?\n/);
    const lines: string[] = [];

    // Then wrap each paragraph
    for (const paragraph of paragraphs) {
      if (paragraph.trim() === '') {
        // Preserve empty lines
        lines.push('');
        continue;
      }

      const words = paragraph.split(' ');
      let currentLine = '';

      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        if (testLine.length <= maxChars) {
          currentLine = testLine;
        } else {
          if (currentLine) {
            lines.push(currentLine);
          }
          currentLine = word;
        }
      }
      if (currentLine) {
        lines.push(currentLine);
      }
    }

    return lines.length > 0 ? lines : [''];
  };

  const handleSvgDoubleClick = (e: React.MouseEvent<SVGSVGElement>) => {
    if (draggingBubbleId) return;
    
    const svg = e.currentTarget;
    const rect = svg.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 800;
    const y = ((e.clientY - rect.top) / rect.height) * 800;

    const dx = x - centerX;
    const dy = y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > middleOuterRadius && distance < outerRingInnerRadius) {
      let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
      if (angle < 0) angle += 360;

      const color = getPastelColorWheelColor(angle);

      const newBubble: BubbleData = {
        id: String(nextBubbleId),
        text: `Bubble ${nextBubbleId}`,
        angle: angle,
        distance: distance,
        color: color,
      };

      setBubbles([...bubbles, newBubble]);
      setNextBubbleId(nextBubbleId + 1);
    }
  };

  const handleBubbleMouseDown = (e: React.MouseEvent, bubbleId: string) => {
    e.stopPropagation();
    setDraggingBubbleId(bubbleId);
  };

  const handleBubbleClick = (e: React.MouseEvent, bubbleId: string) => {
    e.stopPropagation();
    if (draggingBubbleId) return;
    
    setSelectedBubbleId(bubbleId);
    setSelectedLabelId(null);
    setSelectedInnerSectionId(null);
    setSelectedMiddleSectionId(null);
    const bubble = bubbles.find(b => b.id === bubbleId);
    if (bubble) {
      setEditText(bubble.text);
    }
  };

  const handleSvgMouseMove = (e: React.MouseEvent<SVGSVGElement>) => {
    if (!draggingBubbleId) return;

    const svg = e.currentTarget;
    const rect = svg.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 800;
    const y = ((e.clientY - rect.top) / rect.height) * 800;

    const { angle, distance } = cartesianToPolar(x, y);

    const constrainedDistance = Math.max(
      middleOuterRadius + 20,
      Math.min(outerRingInnerRadius - 20, distance)
    );

    const color = getPastelColorWheelColor(angle);

    setBubbles(bubbles.map(b =>
      b.id === draggingBubbleId
        ? { ...b, angle, distance: constrainedDistance, color }
        : b
    ));
  };

  const handleSvgMouseUp = () => {
    setDraggingBubbleId(null);
  };

  const updateBubbleText = () => {
    if (selectedBubbleId && editText.trim()) {
      setBubbles(bubbles.map(b =>
        b.id === selectedBubbleId ? { ...b, text: editText } : b
      ));
      setSelectedBubbleId(null);
      setEditText("");
    }
  };

  const toggleBubbleOutline = () => {
    if (selectedBubbleId) {
      setBubbles(bubbles.map(b =>
        b.id === selectedBubbleId ? { ...b, outlined: !b.outlined } : b
      ));
    }
  };

  const updateLabelText = () => {
    if (selectedLabelId && editText.trim()) {
      setOuterLabels(outerLabels.map(l =>
        l.id === selectedLabelId ? { ...l, text: editText } : l
      ));
      setSelectedLabelId(null);
      setEditText("");
    }
  };

  const updateInnerSectionText = () => {
    if (selectedInnerSectionId && editText.trim()) {
      setInnerSections(innerSections.map(s =>
        s.id === selectedInnerSectionId ? { ...s, text: editText } : s
      ));
      setSelectedInnerSectionId(null);
      setEditText("");
    }
  };

  const updateMiddleSectionText = () => {
    if (selectedMiddleSectionId && editText.trim()) {
      setMiddleSections(middleSections.map(s =>
        s.id === selectedMiddleSectionId ? { ...s, text: editText } : s
      ));
      setSelectedMiddleSectionId(null);
      setEditText("");
    }
  };

  const handleLabelClick = (labelId: string) => {
    setSelectedLabelId(labelId);
    setSelectedBubbleId(null);
    setSelectedInnerSectionId(null);
    setSelectedMiddleSectionId(null);
    const label = outerLabels.find(l => l.id === labelId);
    if (label) {
      setEditText(label.text);
    }
  };

  const handleInnerSectionClick = (e: React.MouseEvent, sectionId: string) => {
    e.stopPropagation();
    setSelectedInnerSectionId(sectionId);
    setSelectedBubbleId(null);
    setSelectedLabelId(null);
    setSelectedMiddleSectionId(null);
    const section = innerSections.find(s => s.id === sectionId);
    if (section) {
      setEditText(section.text);
    }
  };

  const handleMiddleSectionClick = (e: React.MouseEvent, sectionId: string) => {
    e.stopPropagation();
    setSelectedMiddleSectionId(sectionId);
    setSelectedBubbleId(null);
    setSelectedLabelId(null);
    setSelectedInnerSectionId(null);
    const section = middleSections.find(s => s.id === sectionId);
    if (section) {
      setEditText(section.text);
    }
  };

  const deleteBubble = () => {
    if (selectedBubbleId) {
      setBubbles(bubbles.filter(b => b.id !== selectedBubbleId));
      setSelectedBubbleId(null);
      setEditText("");
    }
  };

  const exportToPng = async () => {
    if (!svgRef.current) return;

    try {
      // Clone and prepare SVG
      const svgElement = svgRef.current.cloneNode(true) as SVGSVGElement;
      svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      
      // Get SVG string
      const svgString = new XMLSerializer().serializeToString(svgElement);
      
      // Create a data URL
      const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
      
      // Create canvas
      const canvas = document.createElement("canvas");
      canvas.width = 800;
      canvas.height = 800;
      const ctx = canvas.getContext("2d");
      
      if (!ctx) {
        alert("Failed to create canvas context");
        return;
      }

      // Create image
      const img = new Image();
      
      img.onload = () => {
        // Draw background
        ctx.fillStyle = "#f9fafb";
        ctx.fillRect(0, 0, 800, 800);
        
        // Draw image
        ctx.drawImage(img, 0, 0, 800, 800);
        
        // Convert to PNG and download
        canvas.toBlob((blob) => {
          if (blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "color-wheel-infographic.png";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } else {
            alert("Failed to create PNG blob");
          }
        }, "image/png");
      };

      img.onerror = (e) => {
        console.error("Error loading image:", e);
        alert("PNG export failed. Try using 'Export as SVG' instead, then convert to PNG using an image editor.");
      };

      img.src = svgDataUrl;
      
    } catch (error) {
      console.error("Export error:", error);
      alert("PNG export failed. Try using 'Export as SVG' instead.");
    }
  };

  const exportToSvg = () => {
    if (!svgRef.current) return;

    const svgElement = svgRef.current.cloneNode(true) as SVGSVGElement;
    
    // Add xmlns namespace if not present
    svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    
    const svgData = new XMLSerializer().serializeToString(svgElement);
    const blob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    
    const downloadLink = document.createElement("a");
    downloadLink.href = url;
    downloadLink.download = "color-wheel-infographic.svg";
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    URL.revokeObjectURL(url);
  };

  // =====================================================
  // SAVE PROJECT (download as file)
  // =====================================================
  const saveProjectToFile = () => {
    const data = {
      innerSections,
      middleSections,
      bubbles,
      outerLabels,
      nextBubbleId,
    };

    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    
    const downloadLink = document.createElement("a");
    downloadLink.href = url;
    downloadLink.download = "color-wheel-project.json";
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    URL.revokeObjectURL(url);
  };

  // =====================================================
  // LOAD PROJECT (upload file)
  // =====================================================
  const loadProjectFromFile = () => {
    fileInputRef.current?.click();
  };

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const jsonString = event.target?.result as string;
        const data = JSON.parse(jsonString);

        setInnerSections(data.innerSections || innerSections);
        setMiddleSections(data.middleSections || middleSections);
        setBubbles(data.bubbles || []);
        setOuterLabels(data.outerLabels || outerLabels);
        setNextBubbleId(data.nextBubbleId || nextBubbleId);

        alert("Project loaded successfully!");
      } catch (error) {
        alert("Error loading project file. Please make sure it's a valid project file.");
        console.error("Error parsing project file:", error);
      }
    };
    reader.readAsText(file);
    
    // Reset the input so the same file can be loaded again if needed
    e.target.value = "";
  };

  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50 p-8 gap-8">
      {/* Hidden file input for loading projects */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        onChange={handleFileUpload}
        style={{ display: "none" }}
      />

      <div className="flex flex-col items-center">
        <h1 className="text-3xl mb-8">Color Wheel Infographic</h1>

        <svg
          ref={svgRef}
          width="800"
          height="800"
          viewBox="0 0 800 800"
          xmlns="http://www.w3.org/2000/svg"
          className="max-w-full"
          style={{ cursor: draggingBubbleId ? "grabbing" : "crosshair" }}
          onDoubleClick={handleSvgDoubleClick}
          onMouseMove={handleSvgMouseMove}
          onMouseUp={handleSvgMouseUp}
          onMouseLeave={handleSvgMouseUp}
        >
          <defs>
            <radialGradient id="outerGradient">
              <stop offset="0%" stopColor="white" stopOpacity="0.3" />
              <stop offset="100%" stopColor="white" stopOpacity="0" />
            </radialGradient>

            {/* Conical gradient for smooth color wheel */}
            <defs>
              <linearGradient id="colorWheelGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                {Array.from({ length: 36 }, (_, i) => {
                  const angle = i * 10;
                  const color = getColorWheelColor(angle);
                  return (
                    <stop key={i} offset={`${(i / 36) * 100}%`} stopColor={color} />
                  );
                })}
              </linearGradient>
            </defs>

            {outerLabels.map((label) => {
              const textRadius = (outerRingInnerRadius + outerRingOuterRadius) / 2;
              const pathId = `textPath-${label.id}`;
              return (
                <path
                  key={pathId}
                  id={pathId}
                  d={`
                    M ${centerX + textRadius * Math.cos(((label.angle - 90) * Math.PI) / 180)} 
                      ${centerY + textRadius * Math.sin(((label.angle - 90) * Math.PI) / 180)}
                    A ${textRadius} ${textRadius} 0 0 1 
                      ${centerX + textRadius * Math.cos(((label.angle - 60) * Math.PI) / 180)} 
                      ${centerY + textRadius * Math.sin(((label.angle - 60) * Math.PI) / 180)}
                  `}
                  fill="none"
                />
              );
            })}

            {middleSections.map((section) => {
              const textRadius = (middleInnerRadius + middleOuterRadius) / 2;
              const pathId = `middleTextPath-${section.id}`;
              const startAngle = section.angle;
              const endAngle = section.angle + section.span;
              return (
                <path
                  key={pathId}
                  id={pathId}
                  d={`
                    M ${centerX + textRadius * Math.cos(((startAngle - 90) * Math.PI) / 180)} 
                      ${centerY + textRadius * Math.sin(((startAngle - 90) * Math.PI) / 180)}
                    A ${textRadius} ${textRadius} 0 ${section.span > 180 ? 1 : 0} 1 
                      ${centerX + textRadius * Math.cos(((endAngle - 90) * Math.PI) / 180)} 
                      ${centerY + textRadius * Math.sin(((endAngle - 90) * Math.PI) / 180)}
                  `}
                  fill="none"
                />
              );
            })}
          </defs>

          {/* Outer color ring - using 0.25 degree increments for seamless appearance */}
          {Array.from({ length: 1440 }, (_, i) => i * 0.25).map((angle) => (
            <path
              key={`outer-${angle}`}
              d={createSectionPath(
                centerX,
                centerY,
                outerRingInnerRadius,
                outerRingOuterRadius,
                angle,
                angle + 0.25,
              )}
              fill={getColorWheelColor(angle)}
              opacity={0.9}
              stroke="none"
            />
          ))}

          {outerLabels.map((label) => {
            return (
              <g key={label.id}>
                {/* Text with white stroke outline */}
                <text
                  fill="#4b5563"
                  fontSize="14"
                  fontWeight="800"
                  fontFamily="system-ui, -apple-system, sans-serif"
                  fontStyle="italic"
                  stroke="white"
                  strokeWidth="3"
                  strokeLinejoin="round"
                  paintOrder="stroke fill"
                  style={{ cursor: "pointer" }}
                  onClick={(e) => {
                    e.stopPropagation();
                    handleLabelClick(label.id);
                  }}
                >
                  <textPath
                    href={`#textPath-${label.id}`}
                    startOffset="50%"
                    textAnchor="middle"
                  >
                    {label.text}
                  </textPath>
                </text>
              </g>
            );
          })}

          <circle
            cx={centerX}
            cy={centerY}
            r={bubbleZoneRadius}
            fill="white"
            opacity={0.9}
          />

          {middleSections.map((section) => {
            const startAngle = section.angle;
            const endAngle = section.angle + section.span;
            const midAngle = section.angle + section.span / 2;
            const color = getPastelColorWheelColor(midAngle);
            const isSelected = selectedMiddleSectionId === section.id;

            return (
              <g key={section.id}>
                <path
                  d={createSectionPath(
                    centerX,
                    centerY,
                    middleInnerRadius,
                    middleOuterRadius,
                    startAngle,
                    endAngle,
                  )}
                  fill={color}
                  opacity={0.7}
                  stroke={isSelected ? "#3b82f6" : "white"}
                  strokeWidth={isSelected ? "3" : "2"}
                  className="cursor-pointer"
                  onClick={(e) => handleMiddleSectionClick(e, section.id)}
                />
                <text 
                  fill="#374151"
                  fontSize="12"
                  fontWeight="600"
                  fontFamily="system-ui, -apple-system, sans-serif"
                  pointerEvents="none"
                  onClick={(e) => handleMiddleSectionClick(e, section.id)}
                >
                  <textPath
                    href={`#middleTextPath-${section.id}`}
                    startOffset="50%"
                    textAnchor="middle"
                  >
                    {section.text}
                  </textPath>
                </text>
              </g>
            );
          })}

          {bubbles.map((bubble) => {
            const pos = polarToCartesian(bubble.angle, bubble.distance);
            const lines = wrapText(bubble.text, 20);
            const padding = 16;
            const lineHeight = 14;
            const charWidth = 7;
            
            // Calculate width based on longest line
            const maxLineLength = Math.max(...lines.map(l => l.length));
            const textWidth = maxLineLength * charWidth;
            const rectWidth = Math.max(textWidth + padding * 2, 60);
            const rectHeight = Math.max(lines.length * lineHeight + padding, 30);
            const borderRadius = 8;
            const isSelected = selectedBubbleId === bubble.id;
            const isDragging = draggingBubbleId === bubble.id;

            return (
              <g
                key={bubble.id}
                style={{ cursor: isDragging ? "grabbing" : "grab" }}
                onMouseDown={(e) => handleBubbleMouseDown(e, bubble.id)}
                onClick={(e) => handleBubbleClick(e, bubble.id)}
              >
                {/* Main bubble rectangle */}
                <rect
                  x={pos.x - rectWidth / 2}
                  y={pos.y - rectHeight / 2}
                  width={rectWidth}
                  height={rectHeight}
                  rx={borderRadius}
                  ry={borderRadius}
                  fill={bubble.color}
                  opacity={0.6}
                  stroke={bubble.outlined ? "#4a5568" : "white"}
                  strokeWidth={bubble.outlined ? "4" : "2"}
                />
                {/* Selection indicator - outer glow */}
                {isSelected && (
                  <rect
                    x={pos.x - rectWidth / 2 - 3}
                    y={pos.y - rectHeight / 2 - 3}
                    width={rectWidth + 6}
                    height={rectHeight + 6}
                    rx={borderRadius + 2}
                    ry={borderRadius + 2}
                    fill="none"
                    stroke="#3b82f6"
                    strokeWidth="2"
                    strokeDasharray="5,5"
                    opacity={0.8}
                  />
                )}
                {lines.map((line, index) => (
                  <text
                    key={index}
                    x={pos.x}
                    y={pos.y - (lines.length - 1) * lineHeight / 2 + index * lineHeight}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fill="#1f2937"
                    fontSize="12"
                    fontWeight="500"
                    fontFamily="system-ui, -apple-system, sans-serif"
                    pointerEvents="none"
                  >
                    {line}
                  </text>
                ))}
              </g>
            );
          })}

          {innerSections.map((section, index) => {
            const sectionAngle = 360 / innerSections.length;
            const startAngle = index * sectionAngle;
            const endAngle = (index + 1) * sectionAngle;
            const midAngle = startAngle + sectionAngle / 2;
            const textPos = polarToCartesian(midAngle, innerRadius * 0.55);
            const vibrantColor = getVibrantColorWheelColor(midAngle);
            const isSelected = selectedInnerSectionId === section.id;

            return (
              <g key={section.id}>
                <path
                  d={createSectionPath(
                    centerX,
                    centerY,
                    0,
                    innerRadius,
                    startAngle,
                    endAngle,
                  )}
                  fill={vibrantColor}
                  stroke={isSelected ? "#3b82f6" : "white"}
                  strokeWidth={isSelected ? "3" : "2"}
                  className="cursor-pointer"
                  onClick={(e) => handleInnerSectionClick(e, section.id)}
                />
                <text
                  x={textPos.x}
                  y={textPos.y}
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fill="#ffffff"
                  fontSize="10"
                  fontWeight="700"
                  fontFamily="system-ui, -apple-system, sans-serif"
                  style={{ cursor: "pointer" }}
                  onClick={(e) => handleInnerSectionClick(e, section.id)}
                >
                  {section.text}
                </text>
              </g>
            );
          })}

          <circle cx={centerX} cy={centerY} r={3} fill="white" />
        </svg>

        <div className="flex gap-2 mt-4">
          <button
            onClick={exportToPng}
            className="bg-green-500 text-white px-6 py-3 rounded-md hover:bg-green-600 transition-colors font-semibold"
          >
            Export as PNG
          </button>
          <button
            onClick={exportToSvg}
            className="bg-teal-500 text-white px-6 py-3 rounded-md hover:bg-teal-600 transition-colors font-semibold"
          >
            Export as SVG
          </button>
          <button
            onClick={saveProjectToFile}
            className="bg-blue-500 text-white px-6 py-3 rounded-md hover:bg-blue-600 transition-colors font-semibold"
          >
            Save Project
          </button>
          <button
            onClick={loadProjectFromFile}
            className="bg-orange-500 text-white px-6 py-3 rounded-md hover:bg-orange-600 transition-colors font-semibold"
          >
            Load Project
          </button>
        </div>
      </div>

      {/* Edit Panel */}
      <div className="w-80 bg-white rounded-lg shadow-lg p-6">
        <h2 className="text-xl font-bold mb-4">Edit Content</h2>
        
        {selectedBubbleId && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Edit Bubble Text
              </label>
              <textarea
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                rows={3}
                placeholder="Enter bubble text..."
              />
              <p className="text-xs text-gray-500 mt-1">Max 20 characters per line (auto-wraps). Press Enter for new lines.</p>
            </div>
            
            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                id="outlineCheckbox"
                checked={bubbles.find(b => b.id === selectedBubbleId)?.outlined || false}
                onChange={toggleBubbleOutline}
                className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-2 focus:ring-blue-500"
              />
              <label htmlFor="outlineCheckbox" className="text-sm font-medium text-gray-700 cursor-pointer">
                Add outline (darker border)
              </label>
            </div>

            <div className="flex gap-2">
              <button
                onClick={updateBubbleText}
                className="flex-1 bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition-colors"
              >
                Update
              </button>
              <button
                onClick={deleteBubble}
                className="flex-1 bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition-colors"
              >
                Delete
              </button>
            </div>
            <button
              onClick={() => {
                setSelectedBubbleId(null);
                setEditText("");
              }}
              className="w-full bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 transition-colors"
            >
              Cancel
            </button>
          </div>
        )}

        {selectedLabelId && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Edit Outer Label
              </label>
              <input
                type="text"
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Enter label text..."
              />
            </div>
            <div className="flex gap-2">
              <button
                onClick={updateLabelText}
                className="flex-1 bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition-colors"
              >
                Update
              </button>
              <button
                onClick={() => {
                  setSelectedLabelId(null);
                  setEditText("");
                }}
                className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 transition-colors"
              >
                Cancel
              </button>
            </div>
          </div>
        )}

        {selectedInnerSectionId && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Edit Center Category
              </label>
              <input
                type="text"
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Enter category name..."
              />
            </div>
            <div className="flex gap-2">
              <button
                onClick={updateInnerSectionText}
                className="flex-1 bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition-colors"
              >
                Update
              </button>
              <button
                onClick={() => {
                  setSelectedInnerSectionId(null);
                  setEditText("");
                }}
                className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 transition-colors"
              >
                Cancel
              </button>
            </div>
          </div>
        )}

        {selectedMiddleSectionId && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Edit Middle Section
              </label>
              <input
                type="text"
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Enter section name..."
              />
            </div>
            <div className="flex gap-2">
              <button
                onClick={updateMiddleSectionText}
                className="flex-1 bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition-colors"
              >
                Update
              </button>
              <button
                onClick={() => {
                  setSelectedMiddleSectionId(null);
                  setEditText("");
                }}
                className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-300 transition-colors"
              >
                Cancel
              </button>
            </div>
          </div>
        )}

        {!selectedBubbleId && !selectedLabelId && !selectedInnerSectionId && !selectedMiddleSectionId && (
          <div className="text-sm text-gray-600 space-y-3">
            <p><strong>Instructions:</strong></p>
            <ul className="list-disc list-inside space-y-1">
              <li>Double-click in the white zone to add bubbles</li>
              <li>Click and drag bubbles to move them</li>
              <li>Click bubbles to edit text (auto-wraps at 20 chars)</li>
              <li>Press Enter for new lines in bubble text</li>
              <li>Click outer labels to edit names</li>
              <li>Click center categories to edit</li>
              <li>Click middle sections to edit</li>
              <li>Use Save Project to download your work as a .json file</li>
              <li>Use Load Project to upload and continue a saved project</li>
              <li>Export as PNG when finished</li>
            </ul>
          </div>
        )}
      </div>
    </div>
  );
};

export default ColorWheelInfographic;
